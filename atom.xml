<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JeromeLiu&#39;s 做自己</title>
  <subtitle>地上本无路，庸人自扰之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-19T07:21:39.458Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JeromeLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java HashMap 源码解析</title>
    <link href="http://yoursite.com/2017/04/19/Java-HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/04/19/Java-HashMap-源码解析/</id>
    <published>2017-04-19T02:26:08.000Z</published>
    <updated>2017-04-19T07:21:39.458Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote><br>继上一篇文章<a href="/2017/04/19/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/">Java集合框架综述</a>后，今天正式开始分析具体集合类的代码，首先以既熟悉又陌生的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/HashMap.html" target="_blank" rel="external">HashMap</a>开始。</p>
<h2 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名(signature)"></a>签名(signature)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </div><div class="line">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>可以看到<code style="color:red">HashMap</code>继承了</p>
<ul>
<li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Cloneable.html" target="_blank" rel="external">Cloneable</a>，用于表明HashMap对象会重写java.lang.Object#clone()方法，HashMap实现的是浅拷贝（shallow copy）。</li>
<li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/io/Serializable.html" target="_blank" rel="external">Serializable</a>，用于表明HashMap对象可以被序列化比较有意思的是，HashMap同时继承了抽象类AbstractMap与接口Map，因为抽象类AbstractMap的签名为<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">                <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">  </div></pre></td></tr></table></figure>
<a href="http://stackoverflow.com/questions/14062286/java-why-does-weakhashmap-implement-map-whereas-it-is-already-implemented-by-ab" target="_blank" rel="external">Stack Overfloooow</a>上解释到：<br>在语法层面继承接口<code style="color:red">Map</code>是多余的，这么做仅仅是为了让阅读代码的人明确知道<code style="color:red">HashMap</code>是属于<code style="color:red">Map</code>体系的，起到了文档的作用</li>
</ul>
<p><code style="color:red">AbstractMap</code>相当于个辅助类，<code style="color:red">Map</code>的一些操作这里面已经提供了默认实现，后面具体的子类如果没有特殊行为，可直接使用<code style="color:red">AbstractMap</code>提供的实现。</p>
<h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Cloneable.html" target="_blank" rel="external">Cloneable</a>接口</h3><p><code style="color:red">Cloneable</code>这个接口设计的非常不好，最致命的一点是它里面竟然没有<code style="color:red">clone</code>方法，也就是说我们自己写的类完全可以实现这个接口的同时不重写<code style="color:red">clone</code>方法。<br>关于<code style="color:red">Cloneable</code>的不足，大家可以去看看《Effective Java》一书的作者<a href="http://www.artima.com/intv/bloch13.html" target="_blank" rel="external">给出的理由</a>，在所给链接的文章里，Josh Bloch也会讲如何实现深拷贝比较好，我这里就不在赘述了。</p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/Map.html" target="_blank" rel="external">Map</a>接口</h3><p>在eclipse中的outline面板可以看到<code style="color:red">Map</code>接口里面包含以下成员方法与内部类：<br><img src="/uploads/Java HashMap 源码解析/Map.png" alt="Map"> <div style="margin-left: 250px;font-size: 13px;margin-top: -25px;">Map_field_method</div><br>可以看到，这里的成员方法不外乎是“增删改查”，这也反映了我们编写程序时，一定是以“数据”为导向的。</p>
<p>在<a href="/2017/04/19/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/">上篇文章</a>讲了Map虽然并不是Collection，但是它提供了三种“集合视角”(collection views)，与下面三个方法一一对应：</p>
<ul>
<li><code style="color:red">Set<k> keySet()</k></code>，提供key的集合视角</li>
<li><code style="color:red">Collection<v> values()</v></code>，提供value的集合视角</li>
<li><code style="color:red">Set<map.entry<k, v="">&gt; entrySet()</map.entry<k,></code>，提供key-value序对的集合视角，这里用内部类Map.Entry表示序对</li>
</ul>
<h3 id="AbstractMap抽象类"><a href="#AbstractMap抽象类" class="headerlink" title="AbstractMap抽象类"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/AbstractMap.html" target="_blank" rel="external">AbstractMap</a>抽象类</h3><p>AbstractMap对Map中的方法提供了一个基本实现，减少了实现Map接口的工作量。<br>举例来说：<br>   如果要实现个不可变(unmodifiable)的map，那么只需继承<code style="color:red">AbstractMap</code>，然后实现其<code style="color:red">entrySet</code>方法，这个方法返回的set不支持add与remove，同时这个set的迭代器(iterator)不支持remove操作即可。</p>
<p>   相反，如果要实现个可变(modifiable的map，首先继承<code style="color:red">AbstractMap</code>，然后重写(override)AbstractMap的put方法，同时实现<code style="color:red">entrySet</code>所返回set的迭代器的remove方法即可。</p>
<h2 id="设计理念-design-concept"><a href="#设计理念-design-concept" class="headerlink" title="设计理念(design concept)"></a>设计理念(design concept)</h2><h3 id="哈希表-hash-table"><a href="#哈希表-hash-table" class="headerlink" title="哈希表(hash table)"></a>哈希表(hash table)</h3><p><code style="color:red">HashMap</code>是一种基于<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="external">哈希表(hash table)</a>实现的map，哈希表（也叫关联数组）一种通用的数据结构，大多数的现代语言都原生支持，其概念也比较简单：<code style="color:red">key经过hash函数作用后得到一个槽（buckets或slots）的索引（index），槽中保存着我们想要获取的值</code>，如下图所示<br><img src="/uploads/Java HashMap 源码解析/Hash Table.png" alt="HashTable"> <div style="margin-left: 220px;font-size: 13px;margin-top: -25px;">hash table demo</div></p>
<p>很容易想到，一些不同的key经过同一hash函数后可能产生相同的索引，也就是产生了冲突，这是在所难免的。<br>所以利用哈希表这种数据结构实现具体类时，需要：</p>
<ul>
<li>设计个好的hash函数，使冲突尽可能的减少</li>
<li>其次是需要解决发生冲突后如何处理。</li>
</ul>
<p>后面会重点介绍<code style="color:red">HashMap</code>是如何解决这两个问题的。</p>
<h3 id="HashMap的一些特点"><a href="#HashMap的一些特点" class="headerlink" title="HashMap的一些特点"></a>HashMap的一些特点</h3><ul>
<li>线程非安全，并且允许key与value都为null值，HashTable与之相反，为线程安全，key与value都不允许null值。</li>
<li>不保证其内部元素的顺序，而且随着时间的推移，同一元素的位置也可能改变（resize的情况）</li>
<li>put、get操作的时间复杂度为O(1)。</li>
<li>遍历其集合视角的时间复杂度与其容量（capacity，槽的个数）和现有元素的大小（entry的个数）成正比，所以如果遍历的性能要求很高，不要把capactiy设置的过高或把平衡因子（load factor，当entry数大于capacity*loadFactor时，会进行resize，reside会导致key进行rehash）设置的过低。</li>
<li>由于HashMap是线程非安全的，这也就是意味着如果多个线程同时对一hashmap的集合试图做迭代时有结构的上改变（添加、删除entry，只改变entry的value的值不算结构改变），那么会报ConcurrentModificationException，专业术语叫fail-fast，尽早报错对于多线程程序来说是很有必要的。</li>
<li>Map m = Collections.synchronizedMap(new HashMap(…)); 通过这种方式可以得到一个线程安全的map。</li>
</ul>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>首先从构造函数开始讲，<code style="color:red">HashMap</code>遵循<a href="/2017/04/19/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/">集合框架的约束</a>，提供了一个参数为空的构造函数与有一个参数且参数类型为Map的构造函数。除此之外，还提供了两个构造函数，用于设置<code style="color:red">HashMap</code>的容量（capacity）与平衡因子（loadFactor）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="comment">//桶数组的大小小于0时抛异常</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</div><div class="line">    <span class="comment">//如果桶数组的大小超过最大值，则简单的将桶容量修改为最大值2的30次方</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="comment">//如果负载因子不符合规范，那么抛异常</span></div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = initialCapacity;</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码上可以看到，容量与平衡因子都有个默认值，并且容量有个最大值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The default initial capacity - MUST be a power of two.</div><div class="line"> */</div><div class="line"><span class="comment">//默认的桶数组大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The maximum capacity, used if a higher value is implicitly specified</div><div class="line"> * by either of the constructors with arguments.</div><div class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</div><div class="line"> */</div><div class="line"><span class="comment">//极限值（超过这个值就将threshold修改为Integer.MAX_VALUE（此时桶大小已经是2的31次方了），表明不进行扩容了）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * The load factor used when none specified in constructor.</div><div class="line"> */</div><div class="line"><span class="comment">//负载因子</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure><br>可以看到，默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的最好取值（JDK说是最好的😂），过高的因子会降低存储空间但是查找（lookup，包括HashMap中的put与get方法）的时间就会增加。<br>这里比较奇怪的是问题：容量必须为2的指数倍（默认为16），这是为什么呢？解答这个问题，需要了解HashMap中哈希函数的设计原理。</p>
<h3 id="哈希函数的设计原理"><a href="#哈希函数的设计原理" class="headerlink" title="哈希函数的设计原理"></a>哈希函数的设计原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Retrieve object hash code and applies a supplemental hash function to the</div><div class="line">  * result hash, which defends against poor quality hash functions.  This is</div><div class="line">  * critical because HashMap uses power-of-two length hash tables, that</div><div class="line">  * otherwise encounter collisions for hashCodes that do not differ</div><div class="line">  * in lower bits. Note: Null keys always map to hash 0, thus index 0.</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hashSeed;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">    &#125;</div><div class="line">    h ^= k.hashCode();</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Returns index for hash code h.</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这么多位操作，是不是觉得晕头转向了呢，还是搞清楚原理就行了，毕竟位操作速度是很快的，不能因为不好理解就不用了。<br>网上说这个问题的也比较多，我这里根据自己的理解，尽量做到通俗易懂。<br>在哈希表容量（也就是buckets或slots大小）为length的情况下，为了使每个key都能在冲突最小的情况下映射到<code style="color:red">[0,length)</code>（注意是左闭右开区间）的索引（index）内，一般有两种做法:<br>   <span style="margin-left: 20px;"></span>1.让length为素数，然后用<code style="color:red">hashCode(key) mod length</code>的方法得到索引<br>   <span style="margin-left: 20px;"></span>2.让length为2的指数倍，然后用<code style="color:red">hashCode(key) &amp; (length-1)</code>的方法得到索引<br><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/Hashtable.html" target="_blank" rel="external">HashTable</a>用的是方法1，<code style="color:red">HashMap</code>用的是方法2。<br>因为本篇主题讲的是HashMap，所以关于方法1为什么要用素数，我这里不想过多介绍，大家可以看<a href="https://math.stackexchange.com/questions/183909/why-choose-a-prime-number-as-the-number-of-slots-for-hashing-function-that-uses" target="_blank" rel="external">这里</a>。<br>重点说说方法2的情况，方法2其实也比较好理解：<br><span style="margin-left: 20px;"></span>因为length为2的指数倍，所以<code style="color:red">length-1</code>所对应的二进制位都为1，然后在与<code style="color:red">hashCode(key)</code>做与运算，即可得到<code style="color:red">[0,length)</code>内的索引。<br>但是这里有个问题，如果<code style="color:red">hashCode(key)</code>的大于length的值，而且<code style="color:red">hashCode(key)</code>的二进制位的低位变化不大，那么冲突就会很多，举个例子：<br>   <span style="margin-left: 20px;"></span>Java中对象的哈希值都32位整数，而HashMap默认大小为16，那么有两个对象那么的哈希值分别为：<code style="color:red">0xABAB0000</code>与<code style="color:red">0xBABA0000</code>，它们的后几位都是一样，那么与16异或后得到结果应该也是一样的，也就是产生了冲突。</p>
<p>造成冲突的原因关键在于16限制了只能用低位来计算，高位直接舍弃了，所以我们需要额外的哈希函数而不只是简单的对象的<code style="color:red">hashCode</code>方法了。<br>具体来说，就是HashMap中<code style="color:red">hash</code>函数干的事了。<br>   <span style="margin-left: 20px;"></span>首先有个随机的hashSeed，来降低冲突发生的几率然后如果是字符串，用了<code style="color:red">sun.misc.Hashing.stringHash32((String) k)</code>来获取索引值最后，通过一系列无符号右移操作，来把高位与低位进行异或操作，来降低冲突发生的几率</p>
<p>右移的偏移量20，12，7，4是怎么来的呢？因为Java中对象的哈希值都是32位的，所以这几个数应该就是把高位与低位做异或运算，至于这几个数是如何选取的，就不清楚了，网上搜了半天也没统一且让人信服的说法，大家可以参考下面几个链接：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/7922019/openjdks-rehashing-mechanism/7922219#7922219" target="_blank" rel="external">http://stackoverflow.com/questions/7922019/openjdks-rehashing-mechanism/7922219#7922219</a></li>
<li><a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function/9336103#9336103" target="_blank" rel="external">http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function/9336103#9336103</a></li>
<li><a href="http://stackoverflow.com/questions/14453163/can-anybody-explain-how-java-design-hashmaps-hash-function/14479945#14479945" target="_blank" rel="external">http://stackoverflow.com/questions/14453163/can-anybody-explain-how-java-design-hashmaps-hash-function/14479945#14479945</a></li>
</ul>
<h3 id="HashMap-Entry"><a href="#HashMap-Entry" class="headerlink" title="HashMap.Entry"></a>HashMap.Entry</h3><p>HashMap中存放的是HashMap.Entry对象，它继承自Map.Entry，其比较重要的是构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    <span class="keyword">int</span> hash;</div><div class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">        value = v;</div><div class="line">        next = n;</div><div class="line">        key = k;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// setter, getter, equals, toString 方法省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//用key的hash值与上value的hash值作为Entry的hash值</span></div><div class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Thismethodis invoked whenever the value in an entry is</div><div class="line">     * overwritten by an invocation of put(k,v) for a key k that's already</div><div class="line">     * in the HashMap.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Thismethodis invoked whenever the entry is</div><div class="line">     * removed from the table.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，Entry实现了单向链表的功能，用<code style="color:red">next</code>成员变量来级连起来。<br>介绍完Entry对象，下面要说一个比较重要的成员变量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</div><div class="line"> */</div><div class="line"><span class="comment">//HashMap内部维护了一个为数组类型的Entry变量table，用来保存添加进来的Entry对象</span></div><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure><br>你也许会疑问，Entry不是单向链表嘛，怎么这里又需要个数组类型的table呢？<br>我翻了下之前的算法书，其实这是解决冲突的一个方式：<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining" target="_blank" rel="external">链地址法(开散列法)</a>，效果如下：<br><img src="/uploads/Java HashMap 源码解析/链地址法.gif" alt="链地址法"> <div style="margin-left: 90px;font-size: 13px;">链地址法处理冲突得到的散列表</div><br>就是相同索引值的Entry，会以单向链表的形式存在</p>
<h4 id="链地址法的可视化"><a href="#链地址法的可视化" class="headerlink" title="链地址法的可视化"></a>链地址法的可视化</h4><p>下面的链接可以模仿哈希表采用链地址法解决冲突:</p>
<ul>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" target="_blank" rel="external">https://www.cs.usfca.edu/~galles/visualization/OpenHash.html</a></li>
</ul>
<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>get操作相比put操作简单，所以先介绍get操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">//单独处理key为null的情况</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key为null的Entry用于放在table[0]中，但是在table[0]冲突链中的Entry的key不一定为null</span></div><div class="line">    <span class="comment">//所以需要遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="comment">//首先定位到索引在table中的位置</span></div><div class="line">    <span class="comment">//然后遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="put操作-含update操作"><a href="#put操作-含update操作" class="headerlink" title="put操作(含update操作)"></a>put操作(含update操作)</h3><p>因为put操作有可能需要对HashMap进行resize，所以实现略复杂些<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</div><div class="line">    <span class="comment">//辅助函数，用于填充HashMap到指定的capacity</span></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></div><div class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</div><div class="line">    <span class="comment">//threshold为resize的阈值，超过后HashMap会进行resize，内容的entry会进行rehash</span></div><div class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    initHashSeedAsNeeded(capacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Associates the specified value with the specified key in this map.</div><div class="line">  * If the map previously contained a mapping for the key, the old</div><div class="line">  * value is replaced.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">        inflateTable(threshold);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里的循环是关键</span></div><div class="line">    <span class="comment">//当新增的key所对应的索引i，对应table[i]中已经有值时，进入循环体</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="comment">//判断是否存在本次插入的key，如果存在用本次的value替换之前oldValue，相当于update操作</span></div><div class="line">        <span class="comment">//并返回之前的oldValue</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了</span></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果增加一个元素会后，HashMap的大小超过阈值，需要resize</span></div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        <span class="comment">//增加的幅度是之前的1倍</span></div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先得到该索引处的冲突链Entries，第一次插入bucketIndex位置时冲突链为null，也就是e为null</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    <span class="comment">//然后把新的Entry添加到冲突链的开头，也就是说，后插入的反而在前面（第一次还真没看明白）</span></div><div class="line">    <span class="comment">//table[bucketIndex]为新加入的Entry，是bucketIndex位置的冲突链的第一个元素</span></div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下面看看HashMap是如何进行resize，庐山真面目就要揭晓了😊</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="comment">//如果已经达到最大容量，那么就直接返回</span></div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    <span class="comment">//initHashSeedAsNeeded(newCapacity)的返回值决定了是否需要重新计算Entry的hash值</span></div><div class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</div><div class="line">    table = newTable;</div><div class="line">     threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * Transfers all entries from current table to newTable.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="comment">//遍历当前的table，将里面的元素添加到新的newTable中</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">           <span class="comment">//最后这两句用了与put放过相同的技巧</span></div><div class="line">           <span class="comment">//将后插入的反而在前面</span></div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize the hashing mask value. We defer initialization until we</div><div class="line"> * really need it.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    <span class="comment">//这里说明了，在hashSeed不为0或满足useAltHash时，会重算Entry的hash值</span></div><div class="line">    <span class="comment">//至于useAltHashing的作用可以参考下面的链接</span></div><div class="line">    <span class="comment">// http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap</span></div><div class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</div><div class="line">    <span class="keyword">if</span> (switching) &#123;</div><div class="line">        hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>) : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> switching;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">    <span class="comment">//可以看到删除的key如果存在，就返回其所对应的value</span></div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里用了两个Entry对象，相当于两个指针，为的是防治冲突链发生断裂的情况</span></div><div class="line">    <span class="comment">//这里的思路就是一般的单向链表的删除思路</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="comment">//当table[i]中存在冲突链时，开始遍历里面的元素</span></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            <span class="keyword">if</span> (prev == e) <span class="comment">//当冲突链只有一个Entry时</span></div><div class="line">                table[i] = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在为止，HashMap的增删改查都介绍完了。<br>一般而言，认为HashMap的这四种操作时间复杂度为O(1)，因为它hash函数性质较好，保证了冲突发生的几率较小。</p>
<p>##￥ fast-fail的HashIterator<br>集合类用<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank" rel="external">Iterator</a>类来遍历其包含的元素，<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html" target="_blank" rel="external">接口Enumeration</a>已经不推荐使用。相比Enumeration，Iterator有下面两个优势：<br><span style="margin-left: 20px;"></span>1.Iterator允许调用者在遍历集合类时删除集合类中包含的元素（相比Enumeration增加了remove方法）<br><span style="margin-left: 20px;"></span>2.比Enumeration的命名更简短<br>HashMap中提供的三种集合视角，底层都是用HashIterator实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></div><div class="line">    <span class="comment">//在初始化Iterator实例时，纪录下当前的修改次数</span></div><div class="line">    <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></div><div class="line">    <span class="keyword">int</span> index;              <span class="comment">// current slot</span></div><div class="line">    Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">//遍历HashMap的table，依次查找元素</span></div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//在访问下一个Entry时，判断是否有其他线程有对集合的修改</span></div><div class="line">        <span class="comment">//说明HashMap是线程非安全的</span></div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">        Entry[] t = table;</div><div class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">        current = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Object k = current.key;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIteratorextendsHashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIteratorextendsHashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().getKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIteratorextendsHashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>介绍到这里，基本上算是把HashMap中一些核心的点讲完了，但还有个比较严重的问题：保存Entry的table数组为transient的，也就是说在进行序列化时，并不会包含该成员，这是为什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure><br>为了解答这个问题，我们需要明确下面事实：</p>
<ul>
<li>Object.hashCode方法对于一个类的两个实例返回的是不同的哈希值。</li>
</ul>
<p>我们可以试想下面的场景：<br>    <span style="margin-left: 20px;"></span>我们在机器A上算出对象A的哈希值与索引，然后把它插入到HashMap中，然后把该HashMap序列化后，在机器B上重新算对象的哈希值与索引，这与机器A上算出的是不一样的，所以我们在机器B上get对象A时，会得到错误的结果。<br>    <span style="margin-left: 20px;"></span>所以说，当序列化一个HashMap对象时，保存Entry的table是不需要序列化进来的，因为它在另一台机器上是错误的。</p>
<p>因为这个原因，HashMap重现了<code style="color:red">writeObject</code>与<code style="color:red">readObject</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out number of buckets</span></div><div class="line">    <span class="keyword">if</span> (table==EMPTY_TABLE) &#123;</div><div class="line">        s.writeInt(roundUpToPowerOf2(threshold));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        s.writeInt(table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Write out size (number of Mappings)</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out keys and values (alternating)</span></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</div><div class="line">            s.writeObject(e.getKey());</div><div class="line">            s.writeObject(e.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></div><div class="line">    s.defaultReadObject();</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</div><div class="line">        <span class="function">thrownew <span class="title">InvalidObjectException</span><span class="params">(<span class="string">"Illegal load factor: "</span> +loadFactor)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// set other fields that need values</span></div><div class="line">    table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div><div class="line"></div><div class="line">    <span class="comment">// Read in number of buckets</span></div><div class="line">    s.readInt(); <span class="comment">// ignored.// Read number of mappingsint mappings = s.readInt();</span></div><div class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> + mappings);</div><div class="line"></div><div class="line">    <span class="comment">// capacity chosen by number of mappings and desired load (if &gt;= 0.25)int capacity = (int) Math.min(</span></div><div class="line">            mappings * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</div><div class="line">            <span class="comment">// we have limits...</span></div><div class="line">            HashMap.MAXIMUM_CAPACITY);</div><div class="line"></div><div class="line"><span class="comment">// allocate the bucket array;</span></div><div class="line">    <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</div><div class="line">        inflateTable(capacity);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        threshold = capacity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init();  <span class="comment">// Give subclass a chance to do its thing.// Read the keys and values, and put the mappings in the HashMap</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</div><div class="line">        K key = (K) s.readObject();</div><div class="line">        V value = (V) s.readObject();</div><div class="line">        putForCreate(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = <span class="keyword">null</span> == key ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Look for preexisting entry for key.  This will never happen for</div><div class="line">     * clone or deserialize.  It will only happen for construction if the</div><div class="line">     * input Map is a sorted map whose ordering is inconsistent w/ equals.</div><div class="line">     */</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    createEntry(hash, key, value, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>简单来说，在序列化时，针对Entry的key与value分别单独序列化，当反序列化时，再单独处理即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://supercoderz.in/understanding-transient-variables-in-java-and-how-they-are-practically-used-in-hashmap/" target="_blank" rel="external">http://supercoderz.in/understanding-transient-variables-in-java-and-how-they-are-practically-used-in-hashmap/</a></li>
<li><a href="http://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria" target="_blank" rel="external">http://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt;&lt;br&gt;继上一篇文章&lt;a href=&quot;/2017/04/19/Java%E9%9B%86%E5%90%88%E6%A1%86
    
    </summary>
    
      <category term="编程开发" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架综述</title>
    <link href="http://yoursite.com/2017/04/19/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%BC%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/04/19/Java集合框架综述/</id>
    <published>2017-04-19T01:56:44.000Z</published>
    <updated>2017-04-19T07:51:18.422Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote><br>最近被陆陆续续问了几遍HashMap的实现，回答的不好，打算复习复习JDK中的集合框架，并尝试分析其源码，这么做一方面是这些类非常实用，掌握其实现能更好的优化我们的程序；<br>另一方面是学习借鉴JDK是如何实现了这么一套优雅高效的类库，提升编程能力。<br>在介绍具体适合类之前，本篇文章对Java中的集合框架做一个大致描述，从一个高的角度俯视这个框架，了解了这个框架的一些理念与约定，会大大帮助后面分析某个具体类，让我们开始吧。</p>
<h2 id="集合框架-collections-framework"><a href="#集合框架-collections-framework" class="headerlink" title="集合框架(collections framework)"></a>集合框架(collections framework)</h2><p>首先要明确，集合代表了一组对象(和数组一样，但数组长度不能变，而集合能)。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。<br>其实说白了，可以把一个集合看成一个微型数据库，操作不外乎“增删改查”四种操作，我们在学习使用一个具体的集合类时，需要把这四个操作的<code style="color:red">时空复杂度</code>弄清楚了，基本上就可以说掌握这个类了。</p>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>主要理念用一句话概括就是：提供一套“小而美”的API。API需要对程序员友好，增加新功能时能让程序员们快速上手。<br>为了保证核心接口足够小，最顶层的接口(也就是Collection与Map接口)并不会区分该集合是否可变(mutability),是否可更改(modifiability),是否可改变大小(resizability)这些细微的差别。相反，一些操作是可选的，在实现时抛出<code style="color:red">UnsupportedOperationException</code>即可表示集合不支持该操作。集合的实现者必须在文档中声明那些操作是不支持的。<br>为了保证最顶层的核心接口足够小，它们只能包含下面情况下的方法：</p>
<ol>
<li>基本操作，像之前说的“增删改查”</li>
<li>There is a compelling performance reason why an important implementation would want to override it.</li>
</ol>
<p>此外，所有的集合类都必须能提供友好的交互操作，这包括没有继承<code style="color:red">Collection</code>类的数组对象。因此，框架提供一套方法，让集合类与数组可以相互转化，并且可以把<code style="color:red">Map</code>看作成集合。</p>
<h2 id="两大基类Collection与Map"><a href="#两大基类Collection与Map" class="headerlink" title="两大基类Collection与Map"></a>两大基类Collection与Map</h2><p>在集合框架的类继承体系中，最顶层有两个接口:</p>
<ul>
<li>Collection表示一组纯数据</li>
<li>Map表示一组key-value对</li>
</ul>
<p>一般继承自Collection或Map的集合类，会提供两个“标准”的构造函数:</p>
<ul>
<li>没有参数的构造函数，创建一个空的集合类</li>
<li>有一个类型与基类（Collection或Map）相同的构造函数，创建一个与给定参数具有相同元素的新集合类</li>
</ul>
<p>因为接口中不能包含构造函数，所以上面这两个构造函数的约定并不是强制性的，但是在目前的集合框架中，所有继承自Collection或Map的子类都遵循这一约定。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="/uploads/Java集合框架综述/Collection.jpg" alt="Collection"> <div style="text-align: center;font-size: 13px;margin-top: -25px;">java-collection-hierarchy</div></p>
<p>如上图所示，<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a>类主要有三个接口：</p>
<ul>
<li><code style="color:red">Set</code>表示不允许有重复元素的集合(A collection that contains no duplicate elements)</li>
<li><code style="color:red">List</code>表示允许有重复元素的集合(An ordered collection (also known as a sequence))</li>
<li><code style="color:red">Queue</code> JDK1.5新增，与上面两个集合类主要是的区分在于Queue主要用于存储数据，而不是处理数据。(A collection designed for holding elements prior to processing.)</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/uploads/Java集合框架综述/Map.jpg" alt="Collection"> <div style="margin-left: 250px;font-size: 13px;margin-top: -25px;">MapClassHierarchy</div></p>
<p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="external">Map</a>并不是一个真正意义上的集合(are not true collections)，但是这个接口提供了三种“集合视角”(collection views )，使得可以像操作集合一样操作它们，具体如下：</p>
<ul>
<li>把map的内容看作key的集合(map’s contents to be viewed as a set of keys)</li>
<li>把map的内容看作value的集合(map’s contents to be viewed as a collection of values)</li>
<li>把map的内容看作key-value映射的集合(map’s contents to be viewed as a set of key-value mappings)</li>
</ul>
<h2 id="集合的实现-Collection-Implementations"><a href="#集合的实现-Collection-Implementations" class="headerlink" title="集合的实现(Collection Implementations)"></a>集合的实现(Collection Implementations)</h2><p>实现集合接口的类一般遵循<code style="color:red">&lt;实现方式&gt;+&lt;接口&gt;</code>的命名方式，通用的集合实现类如下表：</p>
<table>
<thead>
<tr>
<th>Interface</th>
<th style="text-align:center">Hash Table</th>
<th style="text-align:center">Resizable Array</th>
<th style="text-align:center">Balanced Tree</th>
<th style="text-align:center">Linked List</th>
<th style="text-align:center">Hash Table + Linked List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set</td>
<td style="text-align:center">HashSet</td>
<td style="text-align:center"></td>
<td style="text-align:center">TreeSet</td>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>List</td>
<td style="text-align:center"></td>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center"></td>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Deque</td>
<td style="text-align:center"></td>
<td style="text-align:center">ArrayDeque</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>Map</td>
<td style="text-align:center"><a href="http://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="external">HashMap</a></td>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="http://liujiacai.net/blog/2015/09/04/java-treemap/" target="_blank" rel="external">TreeMap</a></td>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="">LinkedHashMap</a></td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天先开个头，后面会陆陆续续来一系列干货，Stay Tuned。<br>需要说明一点，今后所有源码分析都将基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="external">Oracle JDK 1.7.0_71</a>，请知悉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ java -version</div><div class="line">java version<span class="string">"1.7.0_71"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.7.0_71-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode)</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Java_collections_framework" target="_blank" rel="external">https://en.wikipedia.org/wiki/Java_collections_framework</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt;&lt;br&gt;最近被陆陆续续问了几遍HashMap的实现，回答的不好，打算复习复习JDK中的集合框架，并尝试分析其源码，这么做一方
    
    </summary>
    
      <category term="编程开发" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java开发" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java集合" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/04/18/hello-world/"/>
    <id>http://yoursite.com/2017/04/18/hello-world/</id>
    <published>2017-04-18T05:14:45.733Z</published>
    <updated>2017-04-18T11:02:13.563Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
</feed>
